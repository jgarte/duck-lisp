;; This is such a hack! XD
#(__defmacro __declare (identifier type &rest script-body) ())

__defmacro declare (identifier type &rest script-body) ()
(__declare declare (L L &rest 0 I)
           (__declare-identifier (__infer-and-get-next-argument) (__infer-and-get-next-argument)))

__defmacro defmacro (name parameters &rest body)
           __cons (__quote __defmacro) (__cons name (__cons parameters body))
(__declare defmacro (L L &rest 1 I)
           (
            (__var name (__infer-and-get-next-argument))
            (__var parameters (__infer-and-get-next-argument))
            (__var type ())
            (
             (__var parameters parameters)
             (__while parameters
                      (__if (__= (__quote &rest) (__car parameters))
                            (__setq type (__cons 0 (__cons (__quote &rest) type)))
                            (__setq type (__cons (__quote I) type)))
                      (__setq parameters (__cdr parameters))))
            (
             (__var type2 type)
             (__setq type ())
             (__while type2
                      (__setq type (__cons (__car type2) type))
                      (__setq type2 (__cdr type2))))
            (__declaration-scope
             (__while parameters
                      (__unless (__= (__quote &rest) (__car parameters))
                                (__declare-identifier (__car parameters) (__quote L)))
                      (__setq parameters (__cdr parameters)))
             (__declare-identifier (__quote self) type)
             (__infer-and-get-next-argument))
            (__declare-identifier name type)))

defmacro defun (name parameters &rest body)
         __cons (__quote __defun) (__cons name (__cons parameters body))
(__declare defun (L L &rest 1 I)
           (
            (__var name (__infer-and-get-next-argument))
            (__var parameters (__infer-and-get-next-argument))
            (__var type ())
            (
             (__var parameters parameters)
             (__while parameters
                      (__if (__= (__quote &rest) (__car parameters))
                            (__setq type (__cons 0 (__cons (__quote &rest) type)))
                            (__setq type (__cons (__quote I) type)))
                      (__setq parameters (__cdr parameters))))
            (
             (__var type2 type)
             (__setq type ())
             (__while type2
                      (__setq type (__cons (__car type2) type))
                      (__setq type2 (__cdr type2))))
            (__declaration-scope
             (__while parameters
                      (__unless (__= (__quote &rest) (__car parameters))
                                (__declare-identifier (__car parameters) (__quote L)))
                      (__setq parameters (__cdr parameters)))
             (__declare-identifier (__quote self) type)
             (__infer-and-get-next-argument))
            (__declare-identifier name type)))

defmacro lambda (parameters &rest body)
         (__cons (__quote __lambda) (__cons parameters body))
(__declare lambda (L &rest 1 I)
           (
            (__var parameters (__infer-and-get-next-argument))
            (__var type ())
            (
             (__var parameters parameters)
             (__while parameters
                      (__if (__= (__quote &rest) (__car parameters))
                            (__setq type (__cons 0 (__cons (__quote &rest) type)))
                            (__setq type (__cons (__quote I) type)))
                      (__setq parameters (__cdr parameters))))
            (
             (__var type2 type)
             (__setq type ())
             (__while type2
                      (__setq type (__cons (__car type2) type))
                      (__setq type2 (__cdr type2))))
            (__declaration-scope
             (__while parameters
                      (__unless (__= (__quote &rest) (__car parameters))
                                (__declare-identifier (__car parameters) (__quote L)))
                      (__setq parameters (__cdr parameters)))
             (__declare-identifier (__quote self) type)
             (__infer-and-get-next-argument))))

defmacro var (name value)
         (__list (__quote __var) name value)
(__declare var (L I) (__declare-identifier (__infer-and-get-next-argument) (__quote L)))


declare print (I)


defmacro if (condition then else)
         (__list (__quote __if) condition then else)

defmacro apply (function &rest args)
         (__cons (__quote __apply) (__cons function args))
declare apply (I &rest 1 I)

defmacro quote (ast) (__list __quote __quote ast)  ; Because I can, *not* because I should.

defun + (a &rest b)
      if b
         __+ a (apply #self b)
         a
declare + (I &rest 1 I)

defun * (a &rest b)
      if b
         (__* a (apply #self b))
         a
declare * (I &rest 1 I)

(defun println (arg)
  print arg
  print "\n"
  arg)

defun list (&rest args) args
defun cons (a d) __cons a d
defun car (c) __car c
defun cdr (c) __cdr c

defun funcall (f &rest args) apply f args
declare funcall (I &rest 1 I)

defun map (f l)
      if l
         cons (#f car l)
              self f (cdr l)
         ()

defun reduce (f l) apply f l

println quote print
println + + 1 2
          + 3 4
println (+ 1 2 3 4)
println * 2 reduce #+ (list 1 2 3 4)
println reduce #+ map lambda (x) * 2 x (list 1 2 3 4)

defun f (a b) (cons a b)
defun g (a b) (cons a b)
declare g (L I)

println f list 3
println g list 3
println (f list 3)
println (g list 3)
println #f list 3
println #g list 3
println (#f list 3)
println (#g list 3)
println #(f list 3)
println #(g list 3)
println ""
println f (list list 3) 3
println g (list list 3) 3
println (f (list list 3) 3)
println (g (list list 3) 3)
println (#f (list list 3) 3)
println (#g (list list 3) 3)
println #(f (list list 3) 3)
println #(g (list list 3) 3)

defun x () "Llama comma"  println x
var   x    "Llama comma"  println x
