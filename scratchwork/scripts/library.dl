(defmacro bothtime (&rest body)
  (list (quote noscope)
        (cons (quote comptime)
              body)
        (cons (quote noscope)
              body)))

(defmacro bvar (name value)
  (list (quote bothtime)
        (list (quote var) name value)))

(defmacro bdefun (name parameters &rest body)
  (var defun (list (quote defun) name parameters))
  (set-cdr (cdr (cdr defun)) body)
  (list (quote bothtime)
        defun
        ()))

(bvar duckLisp-object-type-bool (type-of false))
(bvar duckLisp-object-type-int (type-of 0))
(comment (bvar duckLisp-object-type-float (type-of)))
(bvar duckLisp-object-type-str (type-of ""))
(bvar duckLisp-object-type-list (type-of ()))
(bvar duckLisp-object-type-symbol (type-of (quote _)))
(comment (bvar duckLisp-object-type-function (type-of)))
(bvar duckLisp-object-type-closure (type-of (lambda ())))
(bvar duckLisp-object-type-vector (type-of (vector)))

(bdefun integer? (value)
  (= (type-of value) duckLisp-object-type-int))

(bdefun list? (value)
  (= (type-of value) duckLisp-object-type-list))

(bdefun cons? (value)
  (= (type-of value) duckLisp-object-type-list))

(comment " Copied straight out of CLHS Bï¼‰")

(bdefun caar (x)
  (car (car x)))
(bdefun cadr (x)
  (car (cdr x)))
(bdefun cdar (x)
  (cdr (car x)))
(bdefun cddr (x)
  (cdr (cdr x)))
(bdefun caaar (x)
  (car (car (car x))))
(bdefun caadr (x)
  (car (car (cdr x))))
(bdefun cadar (x)
  (car (cdr (car x))))
(bdefun caddr (x)
  (car (cdr (cdr x))))
(bdefun cdaar (x)
  (cdr (car (car x))))
(bdefun cdadr (x)
  (cdr (car (cdr x))))
(bdefun cddar (x)
  (cdr (cdr (car x))))
(bdefun cdddr (x)
  (cdr (cdr (cdr x))))
(bdefun caaaar (x)
  (car (car (car (car x)))))
(bdefun caaadr (x)
  (car (car (car (cdr x)))))
(bdefun caadar (x)
  (car (car (cdr (car x)))))
(bdefun caaddr (x)
  (car (car (cdr (cdr x)))))
(bdefun cadaar (x)
  (car (cdr (car (car x)))))
(bdefun cadadr (x)
  (car (cdr (car (cdr x)))))
(bdefun caddar (x)
  (car (cdr (cdr (car x)))))
(bdefun cadddr (x)
  (car (cdr (cdr (cdr x)))))
(bdefun cdaaar (x)
  (cdr (car (car (car x)))))
(bdefun cdaadr (x)
  (cdr (car (car (cdr x)))))
(bdefun cdadar (x)
  (cdr (car (cdr (car x)))))
(bdefun cdaddr (x)
  (cdr (car (cdr (cdr x)))))
(bdefun cddaar (x)
  (cdr (cdr (car (car x)))))
(bdefun cddadr (x)
  (cdr (cdr (car (cdr x)))))
(bdefun cdddar (x)
  (cdr (cdr (cdr (car x)))))
(bdefun cddddr (x)
  (cdr (cdr (cdr (cdr x)))))

(bdefun first (list)
  (car list))
(bdefun second (list)
  (car (cdr list)))
(bdefun third (list)
  (car (cddr list)))
(bdefun fourth (list)
  (car (cdddr list)))
(bdefun fifth (list)
  (car (cddddr list)))
(bdefun sixth (list)
  (car (cdr (cddddr list))))
(bdefun seventh (list)
  (car (cddr (cddddr list))))
(bdefun eighth (list)
  (car (cdddr (cddddr list))))
(bdefun ninth (list)
  (car (cddddr (cddddr list))))
(bdefun tenth (list)
  (car (cdr (cddddr (cddddr list)))))

(bdefun rest (x)
  (cdr x))

(bdefun list* (&rest args)
  (if (null? (rest args))
      (first args)
      (cons (first args) (apply self (rest args)))))

(bdefun print (&rest vs)
  (var vs2 vs)
  (while (not (null? vs2))
    (print (car vs2))
    (setq vs2 (cdr vs2)))
  vs)

(bdefun println (&rest vs)
  (apply print vs)
  (print "\n")
  vs)

(defmacro to (variable form)
  (list (quote setq) variable (list* (car form) variable (cdr form))))

(bdefun identity (x) x)

(bdefun 1+ (x)
  (+ x 1))

(bdefun 1- (x)
  (- x 1))

(bdefun >= (x y)
  (not (< x y)))

(bdefun <= (x y)
  (not (> x y)))

(bdefun != (x y)
  (not (= x y)))

(bdefun even? (value)
  (= 0 (- value (* (/ value 2) 2))))
(bdefun odd? (value)
  (not (even? value)))

(bdefun mod (a b)
  (- a (* (/ a b) b)))

(bdefun gcd (a b)
  (while (not (= a b))
    (if (> a b)
        (to a (- b))
        (to b (- a))))
  a)

(bdefun lcm (a b)
  (* a (/ b (gcd a b))))

(defmacro push (value variable)
  (list (quote setq) variable (list (quote cons) value variable)))

(defmacro pop (variable)
  (list
   (list (quote var) (quote pop-temp) (list (quote car) variable))
   (list (quote setq) variable (list (quote cdr) variable))
   (quote pop-temp)))

(bdefun length (list)
  (var i 0)
  (while (not (null? list))
    (to list (cdr))
    (to i (1+)))
  i)

(bdefun nreverse (list)
  (var reversed-list ())
  (while (not (null? list))
    (setq reversed-list (cons (car list)
                              reversed-list))
    (to list (cdr)))
  reversed-list)

(bdefun min (&rest values)
  (var min-value (first values))
  (pop values)
  (while (not (null? values))
         (var value (first values))
         (when (< value min-value)
           (setq min-value value))
         (pop values))
  min-value)

(bdefun max (&rest values)
  (var max-value (first values))
  (pop values)
  (while (not (null? values))
         (var value (first values))
         (when (> value max-value)
           (setq max-value value))
         (pop values))
  max-value)

(bdefun sort-descending (list)
  (quicksort-hoare list (length list)))

(bdefun sort-ascending (list)
  (nreverse (quicksort-hoare list (length list))))

(comment (defun type-to-string (type)
           (switch type
                   duckLisp-object-type-none "none"
                   duckLisp-object-type-bool "bool"
                   duckLisp-object-type-int "int"
                   duckLisp-object-type-float "float"
                   duckLisp-object-type-str "str"
                   duckLisp-object-type-list "list"
                   duckLisp-object-type-symbol "sym"
                   duckLisp-object-type-function "func"
                   duckLisp-object-type-closure "clos")))

(bdefun type-to-string (type)
  (if (= type duckLisp-object-type-none)
      "none"
      (if (= type duckLisp-object-type-bool)
          "bool"
          (if (= type duckLisp-object-type-int)
              "integer"
              (if (= type duckLisp-object-type-float)
                  "float"
                  (if (= type duckLisp-object-type-str)
                      "string"
                      (if (= type duckLisp-object-type-list)
                          "list"
                          (if (= type duckLisp-object-type-symbol)
                              "symbol"
                              (if (= type duckLisp-object-type-function)
                                  "function"
                                  (if (= type duckLisp-object-type-closure)
                                      "closure"
                                      (if (= type duckLisp-object-type-vector)
                                          "vector"
                                          "Invalid type")))))))))))

(defmacro and (&rest args)
  (if args
	  (list (quote if) (car args)
			(apply self (cdr args))
			false)
	  true))

(defmacro or (&rest args)
  (if args
	  (list (quote if) (car args)
			true
			(apply self (cdr args)))
	  false))

(bdefun atom? (v)
  (or (not (or (= (type-of v) duckLisp-object-type-list) (= (type-of v) duckLisp-object-type-vector)))
      (null? v)))

(bdefun subst (x y z)
  (if (atom? z)
      (if (= z y)
          x
          z)
      (cons (self x y (car z))
            (self x y (cdr z)))))

(bdefun pair (x y)
  (if (and (null? x) (null? y))
      ()
      (if (and (not (atom? x)) (not (atom? y)))
          (cons (cons (car x) (cons (car y) ()))
                (self (cdr x) (cdr y)))
          ())))

(bdefun assoc (item alist)
  (if (not (null? alist))
      (if (= (car (car alist)) item)
          (car alist)
          (self item (cdr alist)))
      ()))

(bdefun nthcdr (n list)
  (var i 0)
  (while (< i n)
    (to list (cdr))
    (to i (1+)))
  list)

(bdefun nth (n list)
  (var i 0)
  (while (< i n)
    (to list (cdr))
    (to i (1+)))
  (car list))

(bdefun elt (list n)
  (nth n list))

(bdefun last (list)
  (car (nreverse list)))

(bdefun append (list1 list2)
  (var appended-list ())
  (while (not (null? list1))
    (setq appended-list (cons (car list1)
                              appended-list))
    (to list1 (cdr)))
  (while (not (null? list2))
    (setq appended-list (cons (car list2)
                              appended-list))
    (to list2 (cdr)))
  (nreverse appended-list))

(bdefun copy-list (list)
  (var new-list ())
  (while (not (null? list))
         (setq new-list (cons (car list) new-list))
         (to list (cdr)))
  (nreverse new-list))

(bdefun member (element list)
  (var found false)
  (while (and (not (null? list)) (not found))
    (if (= element (car list))
        (setq found true)
        ())
    (to list (cdr)))
  found)

(bdefun remove-if* (fun list)
  (unless (null? list)
      (if (fun (car list))
          (self fun (cdr list))
          (cons (car list)
                (self fun (cdr list))))))

(bdefun remove-if-not* (fun list)
  (unless (null? list)
      (if (not (fun (car list)))
          (self fun (cdr list))
          (cons (car list)
                (self fun (cdr list))))))

(bdefun maplist* (fun list)
  (unless (null? list)
      (cons (fun list) (self fun (cdr list)))))

(bdefun mapcar* (fun list)
  (unless (null? list)
    (cons (fun (car list)) (self fun (cdr list)))))

(bdefun filter* (fun list)
  (unless (null? list)
    (if (fun (car list))
        (cons (car list) (self fun (cdr list)))
        (self fun (cdr list)))))

(bdefun transpose (lists)
  (comment The operation I've feared doing to linked lists.)
  (comment Create the frame of the transposed matrix.)
  (var new-lists (mapcar* (lambda (element)
							(mapcar* (lambda (element) ()) lists))
						  (first lists)))
  (comment Populate the matrix.)
  (var x 0)
  (while lists
		 (var list (first lists))
		 (var y 0)
		 (while list
				(var element (first list))
				(set-car (nthcdr x (nth y new-lists)) element)
				(pop list)
				(to y (1+)))
		 (pop lists)
		 (to x (1+)))
  new-lists)

(defmacro inc (variable)
  (list (quote to) variable (list (quote 1+))))
(defmacro dec (variable)
  (list (quote to) variable (list (quote 1-))))

(defmacro dolist (bind &rest body)
  (defun nreverse (list)
	(var reversed-list ())
	(while (not (null? list))
		   (setq reversed-list (cons (car list)
									 reversed-list))
           (comment FIXME: `to` doesn't work here?!?)
		   (setq list (cdr list)))
	reversed-list)
  (var variable (car bind))
  (var l (car (cdr bind)))
  (var return (car (cdr (cdr bind))))
  (setq body (nreverse (cons (list (quote pop) (quote dolist-temp))
							 (nreverse body))))
  (list
   (list (quote var) (quote dolist-temp) l)
   (list (quote var) variable ())
   (cons (quote while) (cons (quote dolist-temp)
							 (cons (list (quote setq) variable (list (quote car) (quote dolist-temp)))
								   
								   body)))
   return))

(bdefun subseq (sequence start &rest end)
  (setq sequence (nthcdr start sequence))
  (when end
	(setq end (- (car end) start)))
  (if (and sequence (if end (!= end 0) true))
	  (cons (car sequence) (if end
							   (self (cdr sequence) 0 (1- end))
							   (self (cdr sequence) 0)))
	  ()))

(comment Usage:
         (var ht (make-hash-table (lambda (key) (* 2 key)) (lambda (left right) (= left right))))
         (ht (quote set) 5 10)
         (ht (quote get) 5)  ; â‡’ 10
         (ht (quote get-table))  ; â‡’ The internal representation of the hash table.
         )
(bdefun make-hash-table (size hash-function equal?)
  (var hash-table (make-vector size ()))

  (lambda (message &rest args)
    (defun hash (key)
      (mod (hash-function key) size))

    (defun get-hash (key)
      (var entries (get-vector-element hash-table (hash key)))
      (var found ())
      (while (and entries (not found))
             (var entry (first entries))
             (when (equal? (car entry) key)
               (setq found (car entry)))
             (pop entries))
      found)
    (defun set-hash (key value)
      (var index (hash key))
      (var entries (get-vector-element hash-table index))
      (var found ())
      (
       (var entries entries)
       (while (and entries (not found))
              (var entry (first entries))
              (when (equal? (car entry) key)
                (setq found entries))
              (pop entries)))
      (if found
          (
           (set-cdr (car found) value)
           ())
          (push (cons key value) entries))
      (set-vector-element hash-table index entries)
      value)
    (defun get-table ()
      hash-table)

    (if (= message (quote get))
        (get-hash (first args))
        (if (= message (quote set))
            (set-hash (first args) (second args))
            (if (= message (quote get-table))
                (get-table)
                (println "((make-hash-table)): Unrecognized message " message " with args " args))))))

(comment Pretty continuation passing style, using pointer notation.
         (
          (var place 5)
          (var reference (ref place))
          (print place)             ; â‡’ 5
          (print (dref reference))  ; â‡’ 5
          (setf place 6)
          (print place)             ; â‡’ 6
          (print (dref reference))  ; â‡’ 6
          (setf (dref reference) 7)
          (print (dref reference))  ; â‡’ 7
          (print place))            ; â‡’ 7
         )
(defmacro ref (place)
  (list (quote cons)
        (list (quote lambda) (list) place)
        (list (quote lambda) (list (quote __ref-value))
              (list (quote setq) place (quote __ref-value)))))

(bdefun deref (reference)
  (funcall (car reference)))

(bdefun set-deref (reference value)
  (funcall (cdr reference) value))
