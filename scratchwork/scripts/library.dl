(__comptime (print "<comptime library.dl>\n"))
(print "<library.dl>\n")

(__comptime (print "Gaining sanity\n"))
(__defmacro defmacro (name parameters &rest body) (__cons (__quote __defmacro) (__cons name (__cons parameters body))))
(defmacro quote (form) (__list (__quote __quote) form))
(defmacro list (&rest parameters) (__cons (quote __list) parameters))
(defmacro comment (&rest words) ())
(__defun cons (first second) (__cons first second))
(__comptime (__defun cons (first second) (__cons first second)) ())
(defmacro nop () (list (quote __nop)))
(defmacro noscope (&rest body) (cons (quote __noscope) body))
(defmacro comptime (&rest body) (cons (quote __comptime) body))
(defmacro var (variable value) (list (quote __var) variable value))
(defmacro setq (variable value) (list (quote __setq) variable value))
(defmacro global (variable value) (list (quote __global) variable value))
(defmacro defun (name parameters &rest body) (cons (quote __defun) (cons name (cons parameters body))))
(defmacro lambda (parameters &rest body) (cons (quote __lambda) (cons parameters body)))
(defmacro funcall (function &rest arguments) (cons (quote __funcall) (cons function arguments)))
(defmacro apply (function &rest arguments) (cons (quote __apply) (cons function arguments)))
(defmacro if (condition then else) (list (quote __if) condition then else))
(defmacro when (condition then) (list (quote __when) condition then))
(defmacro unless (condition else) (list (quote __when) condition else))
(defmacro while (condition &rest body) (cons (quote __while) (cons condition body)))
(defmacro vector (&rest arguments) (cons (quote __vector) arguments))
(defmacro error (string) (list (quote __error) string))

(defmacro bothtime (&rest body)
  (list (quote noscope)
        (cons (quote comptime)
              body)
        (cons (quote noscope)
              body)))

(defmacro bvar (name value)
  (funcall bothtime (list (quote var) name value)))

(defmacro bdefun (name parameters &rest body)
  (var defun (list (quote __defun) name parameters))
  (__set-cdr (__cdr (__cdr defun)) body)
  (funcall bothtime defun ()))

(bdefun make-vector (size init) (__make-vector size init))
(bdefun get-vector-element (vector index) (__get-vector-element vector index))
(bdefun set-vector-element (vector index value) (__set-vector-element vector index value))
(bdefun car (cons) (__car cons))
(bdefun cdr (cons) (__cdr cons))
(bdefun set-car (cons value) (__set-car cons value))
(bdefun set-cdr (cons value) (__set-cdr cons value))
(bdefun make-type () (__make-type))
(bdefun make-instance (type value-slot function-slot) (__make-instance type value-slot function-slot))
(bdefun composite-value (composite) (__composite-value composite))
(bdefun composite-function (composite) (__composite-function composite))
(bdefun set-composite-value (composite value) (__set-composite-value composite value))
(bdefun set-composite-function (composite function) (__set-composite-function composite function))
(bdefun null? (value) (__null? value))
(bdefun type-of (value) (__type-of value))
(bdefun not (value) (__not value))
(bdefun * (a b) (__* a b))
(bdefun / (a b) (__/ a b))
(bdefun + (a b) (__+ a b))
(bdefun - (a b) (__- a b))
(bdefun = (a b) (__= a b))
(bdefun < (a b) (__< a b))
(bdefun > (a b) (__> a b))

(comptime (print "Sanity achieved!\n") ())

(bvar duckLisp-object-type-bool (type-of false))
(bvar duckLisp-object-type-int (type-of 0))
(bvar duckLisp-object-type-str (type-of ""))
(bvar duckLisp-object-type-list (type-of ()))
(bvar duckLisp-object-type-symbol (type-of (quote _)))
(bvar duckLisp-object-type-closure (type-of (lambda ())))
(bvar duckLisp-object-type-vector (type-of (vector)))
(bvar duckLisp-object-type-type (type-of (type-of ())))

(bdefun bool? (value)
        (= (type-of value) duckLisp-object-type-bool))

(bdefun integer? (value)
        (= (type-of value) duckLisp-object-type-int))

(bdefun string? (value)
        (= (type-of value) duckLisp-object-type-str))

(bdefun list? (value)
        (= (type-of value) duckLisp-object-type-list))

(bdefun cons? (value)
        (= (type-of value) duckLisp-object-type-list))

(bdefun symbol? (value)
        (= (type-of value) duckLisp-object-type-symbol))

(bdefun closure? (value)
        (= (type-of value) duckLisp-object-type-closure))

(bdefun vector? (value)
        (= (type-of value) duckLisp-object-type-vector))

(bdefun type? (value)
        (= (type-of value) duckLisp-object-type-type))

(comment " Copied straight out of CLHS B）")

(bdefun caar (x)
        (car (car x)))
(bdefun cadr (x)
        (car (cdr x)))
(bdefun cdar (x)
        (cdr (car x)))
(bdefun cddr (x)
        (cdr (cdr x)))
(bdefun caaar (x)
        (car (car (car x))))
(bdefun caadr (x)
        (car (car (cdr x))))
(bdefun cadar (x)
        (car (cdr (car x))))
(bdefun caddr (x)
        (car (cdr (cdr x))))
(bdefun cdaar (x)
        (cdr (car (car x))))
(bdefun cdadr (x)
        (cdr (car (cdr x))))
(bdefun cddar (x)
        (cdr (cdr (car x))))
(bdefun cdddr (x)
        (cdr (cdr (cdr x))))
(bdefun caaaar (x)
        (car (car (car (car x)))))
(bdefun caaadr (x)
        (car (car (car (cdr x)))))
(bdefun caadar (x)
        (car (car (cdr (car x)))))
(bdefun caaddr (x)
        (car (car (cdr (cdr x)))))
(bdefun cadaar (x)
        (car (cdr (car (car x)))))
(bdefun cadadr (x)
        (car (cdr (car (cdr x)))))
(bdefun caddar (x)
        (car (cdr (cdr (car x)))))
(bdefun cadddr (x)
        (car (cdr (cdr (cdr x)))))
(bdefun cdaaar (x)
        (cdr (car (car (car x)))))
(bdefun cdaadr (x)
        (cdr (car (car (cdr x)))))
(bdefun cdadar (x)
        (cdr (car (cdr (car x)))))
(bdefun cdaddr (x)
        (cdr (car (cdr (cdr x)))))
(bdefun cddaar (x)
        (cdr (cdr (car (car x)))))
(bdefun cddadr (x)
        (cdr (cdr (car (cdr x)))))
(bdefun cdddar (x)
        (cdr (cdr (cdr (car x)))))
(bdefun cddddr (x)
        (cdr (cdr (cdr (cdr x)))))

(bdefun first (list)
        (car list))
(bdefun second (list)
        (car (cdr list)))
(bdefun third (list)
        (car (cddr list)))
(bdefun fourth (list)
        (car (cdddr list)))
(bdefun fifth (list)
        (car (cddddr list)))
(bdefun sixth (list)
        (car (cdr (cddddr list))))
(bdefun seventh (list)
        (car (cddr (cddddr list))))
(bdefun eighth (list)
        (car (cdddr (cddddr list))))
(bdefun ninth (list)
        (car (cddddr (cddddr list))))
(bdefun tenth (list)
        (car (cdr (cddddr (cddddr list)))))

(bdefun rest (x)
        (cdr x))

(bdefun list* (&rest args)
        (if (null? (rest args))
            (first args)
            (cons (first args) (apply self (rest args)))))

(bdefun print (&rest vs)
        (var vs2 vs)
        (while (not (null? vs2))
          (print (car vs2))
          (setq vs2 (cdr vs2)))
        vs)

(bdefun println (&rest vs)
        (apply print vs)
        (print "\n")
        vs)

(defmacro to (variable form)
  (list (quote setq) variable (list* (car form) variable (cdr form))))

(bdefun identity (x) x)

(bdefun 1+ (x)
        (+ x 1))

(bdefun 1- (x)
        (- x 1))

(bdefun >= (x y)
        (not (< x y)))

(bdefun <= (x y)
        (not (> x y)))

(bdefun != (x y)
        (not (= x y)))

(bdefun < (x y)
        (< x y))

(bdefun > (x y)
        (> x y))

(bdefun = (x y)
        (= x y))

(bdefun even? (value)
        (= 0 (- value (* (/ value 2) 2))))
(bdefun odd? (value)
        (not (even? value)))

(bdefun mod (a b)
        (- a (* (/ a b) b)))

(bdefun gcd (a b)
        (while (not (= a b))
          (if (> a b)
              (to a (- b))
              (to b (- a))))
        a)

(bdefun lcm (a b)
        (* a (/ b (gcd a b))))

(defmacro push (value variable)
  (list (quote setq) variable (list (quote cons) value variable)))

(defmacro pop (variable)
  (list
   (list (quote var) (quote pop-temp) (list (quote car) variable))
   (list (quote setq) variable (list (quote cdr) variable))
   (quote pop-temp)))

(bdefun length (list)
        (var i 0)
        (while (not (null? list))
          (to list (cdr))
          (to i (1+)))
        i)

(bdefun nreverse (list)
        (var reversed-list ())
        (while (not (null? list))
          (setq reversed-list (cons (car list)
                                    reversed-list))
          (to list (cdr)))
        reversed-list)

(bdefun min (&rest values)
        (var min-value (first values))
        (pop values)
        (while (not (null? values))
          (var value (first values))
          (when (< value min-value)
            (setq min-value value))
          (pop values))
        min-value)

(bdefun max (&rest values)
        (var max-value (first values))
        (pop values)
        (while (not (null? values))
          (var value (first values))
          (when (> value max-value)
            (setq max-value value))
          (pop values))
        max-value)

(bdefun sort-descending (list)
        (quicksort-hoare list (length list)))

(bdefun sort-ascending (list)
        (nreverse (quicksort-hoare list (length list))))

(defmacro and (&rest args)
  (if args
	  (list (quote if) (car args)
			(apply self (cdr args))
			false)
	  true))

(defmacro or (&rest args)
  (if args
	  (list (quote if) (car args)
			true
			(apply self (cdr args)))
	  false))

(bdefun error (message)
        (println "Macro error: " message)
        (list (quote error) message))

(bdefun truthy-constant? (value)
        (or (= value true)
            (and (string? value) value)
            (and (integer? value) value)))
(bdefun falsy-constant? (value)
        (or (= value false)
            (and (string? value) (not value))
            (and (integer? value) (not value))))

(comment This is not the traditional lisp cond.
         (cond first-condition first-body
               second-condition second-body
               third-condition third-body
               … …))
(defmacro cond (&rest body)
  (if body
      (if (cdr body)
          (
           (var condition (first body))
           (if (truthy-constant? condition)
               (second body)
               (if (falsy-constant? condition)
                   (apply self (cddr body))
                   (list (quote if)
                         condition
                         (second body)
                         (apply self (cddr body))))))
          (first body))
      ()))

(defmacro switch (constant &rest body)
  (if body
      (if (cdr body)
          (list (quote if)
                (list (quote =) constant (first body))
                (second body)
                (apply self constant (cddr body)))
          (first body))
      ()))

(bdefun type-to-string (type)
        (switch type
                duckLisp-object-type-bool "Bool"
                duckLisp-object-type-int "Integer"
                duckLisp-object-type-str "String"
                duckLisp-object-type-list "List"
                duckLisp-object-type-symbol "Symbol"
                duckLisp-object-type-closure "Closure"
                duckLisp-object-type-vector "Vector"
                duckLisp-object-type-type "Type"
                "error: Invalid type"))

(bdefun atom? (v)
        (or (not (or (= (type-of v) duckLisp-object-type-list)
                     (= (type-of v) duckLisp-object-type-vector)))
            (null? v)))

(bdefun subst (x y z)
        (if (atom? z)
            (if (= z y)
                x
                z)
            (cons (self x y (car z))
                  (self x y (cdr z)))))

(bdefun pair (x y)
        (if (and (null? x) (null? y))
            ()
            (if (and (not (atom? x)) (not (atom? y)))
                (cons (cons (car x) (cons (car y) ()))
                      (self (cdr x) (cdr y)))
                ())))

(bdefun assoc (item alist)
        (if (not (null? alist))
            (if (= (car (car alist)) item)
                (car alist)
                (self item (cdr alist)))
            ()))

(bdefun nthcdr (n list)
        (var i 0)
        (while (< i n)
          (to list (cdr))
          (to i (1+)))
        list)

(bdefun nth (n list)
        (var i 0)
        (while (< i n)
          (to list (cdr))
          (to i (1+)))
        (car list))

(bdefun elt (list n)
        (nth n list))

(bdefun last (list)
        (car (nreverse list)))

(bdefun append (list1 list2)
        (var appended-list ())
        (while (not (null? list1))
          (setq appended-list (cons (car list1)
                                    appended-list))
          (to list1 (cdr)))
        (while (not (null? list2))
          (setq appended-list (cons (car list2)
                                    appended-list))
          (to list2 (cdr)))
        (nreverse appended-list))

(bdefun copy-list (list)
        (var new-list ())
        (while (not (null? list))
          (setq new-list (cons (car list) new-list))
          (to list (cdr)))
        (nreverse new-list))

(bdefun member (element list)
        (var found false)
        (while (and (not (null? list)) (not found))
          (if (= element (car list))
              (setq found true)
              ())
          (to list (cdr)))
        found)

(bdefun remove-if* (fun list)
        (unless (null? list)
          (if (fun (car list))
              (self fun (cdr list))
              (cons (car list)
                    (self fun (cdr list))))))

(bdefun remove-if-not* (fun list)
        (unless (null? list)
          (if (not (fun (car list)))
              (self fun (cdr list))
              (cons (car list)
                    (self fun (cdr list))))))

(bdefun maplist* (fun list)
        (unless (null? list)
          (cons (fun list) (self fun (cdr list)))))

(bdefun mapcar* (fun list)
        (unless (null? list)
          (cons (fun (car list)) (self fun (cdr list)))))

(bdefun filter* (fun list)
        (unless (null? list)
          (if (fun (car list))
              (cons (car list) (self fun (cdr list)))
              (self fun (cdr list)))))

(bdefun transpose (lists)
        (comment The operation I've feared doing to linked lists.)
        (comment Create the frame of the transposed matrix.)
        (var new-lists (mapcar* (lambda (element)
							      (mapcar* (lambda (element) ()) lists))
						        (first lists)))
        (comment Populate the matrix.)
        (var x 0)
        (while lists
		  (var list (first lists))
		  (var y 0)
		  (while list
			(var element (first list))
			(set-car (nthcdr x (nth y new-lists)) element)
			(pop list)
			(to y (1+)))
		  (pop lists)
		  (to x (1+)))
        new-lists)

(defmacro inc (variable)
  (funcall to variable (list (quote 1+))))
(defmacro dec (variable)
  (funcall to variable (list (quote 1-))))

(bdefun subseq (sequence start &rest end)
        (setq sequence (nthcdr start sequence))
        (when end
	      (setq end (- (car end) start)))
        (if (and sequence (if end (!= end 0) true))
	        (cons (car sequence) (if end
							         (self (cdr sequence) 0 (1- end))
							         (self (cdr sequence) 0)))
	        ()))

(comment Usage:
         (var ht (make-hash-table (lambda (key) (* 2 key)) (lambda (left right) (= left right))))
         (ht (quote set) 5 10)
         (ht (quote get) 5)  ; ⇒ 10
         (ht (quote get-table))  ; ⇒ The internal representation of the hash table.
         )
(bdefun make-hash-table (size hash-function equal?)
        (var hash-table (make-vector size ()))

        (lambda (message &rest args)
          (defun hash (key)
            (mod (hash-function key) size))

          (defun get-hash (key)
            (var entries (get-vector-element hash-table (hash key)))
            (var found ())
            (while (and entries (not found))
              (var entry (first entries))
              (when (equal? (car entry) key)
                (setq found (car entry)))
              (pop entries))
            found)
          (defun set-hash (key value)
            (var index (hash key))
            (var entries (get-vector-element hash-table index))
            (var found ())
            (
             (var entries entries)
             (while (and entries (not found))
               (var entry (first entries))
               (when (equal? (car entry) key)
                 (setq found entries))
               (pop entries)))
            (if found
                (
                 (set-cdr (car found) value)
                 ())
                (push (cons key value) entries))
            (set-vector-element hash-table index entries)
            value)
          (defun get-table ()
            hash-table)

          (if (= message (quote get))
              (get-hash (first args))
              (if (= message (quote set))
                  (set-hash (first args) (second args))
                  (if (= message (quote get-table))
                      (get-table)
                      (println "((make-hash-table)): Unrecognized message " message " with args " args))))))

(comment Pretty continuation passing style, using pointer notation.
         (
          (var place 5)
          (var reference (ref place))
          (print place)             ; ⇒ 5
          (print (dref reference))  ; ⇒ 5
          (setf place 6)
          (print place)             ; ⇒ 6
          (print (dref reference))  ; ⇒ 6
          (setf (dref reference) 7)
          (print (dref reference))  ; ⇒ 7
          (print place))            ; ⇒ 7
         )
(defmacro ref (place)
  (var ref-value (gensym))
  (list (quote cons)
        (list (quote lambda) (list) place)
        (list (quote lambda) (list ref-value)
              (list (quote setq) place ref-value))))

(bdefun deref (reference)
        (funcall (car reference)))

(bdefun set-deref (reference value)
        (funcall (cdr reference) value))


(comment Not the typical `let*'.
         (let* (x 4
                y 3
                z 8
                w 0)
           (setq w (* x y))
           (+ z w)))
(defmacro let* (bindings &rest body)
  (var vars (list (quote noscope)))
  (while bindings
    (push (list (quote var) (first bindings) (second bindings)) vars)
    (to bindings (cddr)))
  (if (null? vars)
      (list body)
      (list* (nreverse vars) body)))

(comment Not the typical `let'.
         (let (x 4
               y 3
               z 8
               w 0)
           (setq w (* x y))
           (+ z w)))
(defmacro let (bindings &rest body)
  (apply let* bindings body))

(comment Not the typical `dotimes'.
         (dotimes i 4
                  (println i))
         In the above example, the numbers 0-3 are printed.
         `top' is only evaluated once. Returns `top'.)
(defmacro dotimes (variable top &rest body)
  (var top-var (gensym))
  (list
   (list (quote var) variable 0)
   (list (quote var) top-var top)
   (list (quote while) (list (quote <) variable top-var)
         (list* (quote noscope) body)
         (list (quote to) variable (quote (1+))))
   top-var))

(comment Like `dolist`, but for generic sequences.
         (dosequence i (list 1 2 3)
                     (println i))
         In the above example, the numbers 1-3 are printed.
         Returns the sequence. It is only evaluated once.)
(defmacro dosequence (variable sequence &rest body)
  (var sequence-var (gensym))
  (var return-var (gensym))
  (list
   (list (quote var) variable ())
   (list (quote var) sequence-var sequence)
   (list (quote var) return-var sequence)
   (list (quote while) sequence-var
         (list (quote setq) variable (list (quote car) sequence-var))
         (apply noscope
                body)
         (funcall to sequence-var (quote (cdr))))
   return-var))

(comment Not the typical `dolist'.
         (dolist i (list 1 2 3)
                 (println i))
         In the above example, the numbers 1-3 are printed.
         Returns the list. It is only evaluated once.)
(defmacro dolist (variable sequence &rest body)
  (apply dosequence variable sequence body))

(defmacro progn (&rest body)
  (list* () body))


(comptime (println "</comptime library.dl>"))
(println "</library.dl>")

(comment If we are going to pause anywhere, this is the place)
(garbage-collect)
