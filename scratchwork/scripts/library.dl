
(var duckLisp-object-type-none 0)
(var duckLisp-object-type-bool 1)
(var duckLisp-object-type-int 2)
(var duckLisp-object-type-float 3)
(var duckLisp-object-type-str 4)
(var duckLisp-object-type-list 5)
(var duckLisp-object-type-symbol 6)
(var duckLisp-object-type-function 7)
(var duckLisp-object-type-closure 8)

(defun print (&rest vs)
  (var vs2 vs)
  (while (not (null? vs2))
	(print (car vs2))
	(setq vs2 (cdr vs2)))
  vs)

(defun println (&rest vs)
  (apply print vs)
  (print "\n")
  vs)

(defun identity (x) x)

(defun 1+ (x)
  (+ x 1))

(defun >= (x y)
  (not (< x y)))

(defun <= (x y)
  (not (> x y)))

(defun evenp (value)
  (= 0 (- value (* (/ value 2) 2))))
(defun oddp (value)
  (not (evenp value)))

(defun gcd (a b)
  (while (not (= a b))
	(if (> a b)
		(setq a (- a b))
		(setq b (- b a))))
  a)

(defun lcm (a b)
  (* a (/ b (gcd a b))))

(comment (defun type-to-string (type)
		   (switch type
				   duckLisp-object-type-none "none"
				   duckLisp-object-type-bool "bool"
				   duckLisp-object-type-int "int"
				   duckLisp-object-type-float "float"
				   duckLisp-object-type-str "str"
				   duckLisp-object-type-list "list"
				   duckLisp-object-type-symbol "sym"
				   duckLisp-object-type-function "func"
				   duckLisp-object-type-closure "clos")))

(defun type-to-string (type)
  (if (= type duckLisp-object-type-none)
	  "none"
	  (if (= type duckLisp-object-type-bool)
		  "bool"
		  (if (= type duckLisp-object-type-int)
			  "int"
			  (if (= type duckLisp-object-type-float)
				  "float"
				  (if (= type duckLisp-object-type-str)
					  "str"
					  (if (= type duckLisp-object-type-list)
						  "list"
						  (if (= type duckLisp-object-type-symbol)
							  "sym"
							  (if (= type duckLisp-object-type-function)
								  "func"
								  (if (= type duckLisp-object-type-closure)
									  "clos"
									  "Invalid type"))))))))))

(defun and (a b)
  (if a
	  (if b
		  true
		  false)
	  false))

(defun or (a b)
  (if a
	  true
	  (if b
		  true
		  false)))

(defun atom? (v)
  (or (not (= (type-of v) duckLisp-object-type-list))
	  (null? v)))

(defun subst (x y z)
  (if (atom? z)
	  (if (= z y)
		  x
		  z)
	  (cons (self x y (car z))
			(self x y (cdr z)))))

(defun pair (x y)
  (if (and (null? x) (null? y))
	  ()
	  (if (and (not (atom? x)) (not (atom? y)))
		  (cons (cons (car x) (cons (car y) ()))
				(self (cdr x) (cdr y)))
		  ())))

(defun assoc (x y)
  (var duckLisp-object-type-list 5)
  (if (not (null? y))
	  (if (= (car (car y)) x)
		  (car (cdr (car y)))
		  (self x (cdr y)))
	  ()))

(defun nthcdr (n list)
  (var i 0)
  (while (< i n)
	(setq list (cdr list))
	(setq i (1+ i)))
  list)

(defun nth (n list)
  (var i 0)
  (while (< i n)
	(setq list (cdr list))
	(setq i (1+ i)))
  (car list))

(defun elt (list n)
  (nth n list))

(defun length (list)
  (var i 0)
  (while (not (null? list))
	(setq list (cdr list))
    (setq i (1+ i)))
  i)

(defun nreverse (list)
  (var reversed-list ())
  (while (not (null? list))
	(setq reversed-list (cons (car list)
							  reversed-list))
	(setq list (cdr list)))
  reversed-list)

(defun last (list)
  (car (nreverse list)))

(defun append (list1 list2)
  (var appended-list ())
  (while (not (null? list1))
	(setq appended-list (cons (car list1)
							  appended-list))
	(setq list1 (cdr list1)))
  (while (not (null? list2))
	(setq appended-list (cons (car list2)
							  appended-list))
	(setq list2 (cdr list2)))
  (nreverse appended-list))

(defun copy-list (list)
  (var new-list ())
  (while (not (null? list))
		 (setq new-list (cons (car list) new-list))
		 (setq list (cdr list)))
  (nreverse new-list))

(defun member (element list)
  (var found false)
  (while (and (not (null? list)) (not found))
	(if (= element (car list))
		(setq found true)
	    ())
	(setq list (cdr list)))
  found)

(comment " Copied straight out of CLHS Bï¼‰")

(defun caar (x)
  (car (car x)))
(defun cadr (x)
  (car (cdr x)))
(defun cdar (x)
  (cdr (car x)))
(defun cddr (x)
  (cdr (cdr x)))
(defun caaar (x)
  (car (car (car x))))
(defun caadr (x)
  (car (car (cdr x))))
(defun cadar (x)
  (car (cdr (car x))))
(defun caddr (x)
  (car (cdr (cdr x))))
(defun cdaar (x)
  (cdr (car (car x))))
(defun cdadr (x)
  (cdr (car (cdr x))))
(defun cddar (x)
  (cdr (cdr (car x))))
(defun cdddr (x)
  (cdr (cdr (cdr x))))
(defun caaaar (x)
  (car (car (car (car x)))))
(defun caaadr (x)
  (car (car (car (cdr x)))))
(defun caadar (x)
  (car (car (cdr (car x)))))
(defun caaddr (x)
  (car (car (cdr (cdr x)))))
(defun cadaar (x)
  (car (cdr (car (car x)))))
(defun cadadr (x)
  (car (cdr (car (cdr x)))))
(defun caddar (x)
  (car (cdr (cdr (car x)))))
(defun cadddr (x)
  (car (cdr (cdr (cdr x)))))
(defun cdaaar (x)
  (cdr (car (car (car x)))))
(defun cdaadr (x)
  (cdr (car (car (cdr x)))))
(defun cdadar (x)
  (cdr (car (cdr (car x)))))
(defun cdaddr (x)
  (cdr (car (cdr (cdr x)))))
(defun cddaar (x)
  (cdr (cdr (car (car x)))))
(defun cddadr (x)
  (cdr (cdr (car (cdr x)))))
(defun cdddar (x)
  (cdr (cdr (cdr (car x)))))
(defun cddddr (x)
  (cdr (cdr (cdr (cdr x)))))

(defun first (list)
  (car list))
(defun second (list)
  (car (cdr list)))
(defun third (list)
  (car (cddr list)))
(defun fourth (list)
  (car (cdddr list)))
(defun fifth (list)
  (car (cddddr list)))
(defun sixth (list)
  (car (cdr (cddddr list))))
(defun seventh (list)
  (car (cddr (cddddr list))))
(defun eighth (list)
  (car (cdddr (cddddr list))))
(defun ninth (list)
  (car (cddddr (cddddr list))))
(defun tenth (list)
  (car (cdr (cddddr (cddddr list)))))

(defun rest (x)
  (cdr x))

(defun remove-if (fun list)
  (unless (null? list)
	  (if (fun (car list))
		  (self fun (cdr list))
		  (cons (car list)
				(self fun (cdr list))))))

(defun remove-if-not (fun list)
  (unless (null? list)
	  (if (not (fun (car list)))
		  (self fun (cdr list))
		  (cons (car list)
				(self fun (cdr list))))))

(defun maplist (fun list)
  (unless (null? list)
	  (cons (fun list) (self fun (cdr list)))))

(defun mapcar (fun list)
  (unless (null? list)
	(cons (fun (car list)) (self fun (cdr list)))))
