comptime print "<comptime library.hna>\n"
print "<library.hna>\n"

(declare var (L I) (declare-identifier (infer-and-get-next-argument) (quote #I)))

(defmacro lvar (name value)
  (list (quote #__var) name value))
(declare lvar (L I) (declare-identifier (infer-and-get-next-argument) (quote #L)))

(defmacro defmacro (name parameters type &rest body)
  (when (not = (type-of parameters) (type-of ()))
    setq parameters (list parameters))
  (when (not = (type-of type) (type-of ()))
    setq type (list type))
  cons (quote #__defmacro) (cons name (cons parameters body)))
(declare defmacro (L L L &rest 1 I)
         (
          (var name (infer-and-get-next-argument))
          (var parameters (infer-and-get-next-argument))
          (when (not = (type-of parameters) (type-of ()))
            setq parameters (list parameters))
          (var type (infer-and-get-next-argument))
          (when (not = (type-of type) (type-of ()))
            setq type (list type))
          (declaration-scope
           (while parameters
                  var parameter car parameters
                  (unless (= (quote #&rest) parameter)
                    (declare-identifier parameter (quote #I)))
                  (setq parameters (cdr parameters)))
           (declare-identifier (quote #self) type)
           (infer-and-get-next-argument))
          (declare-identifier name type)))

(defmacro defun (name parameters &rest body) (L L &rest 1 I)
  (when (not = (type-of parameters) (type-of ()))
    setq parameters (list parameters))
  var new-parameters ()
  ;; Dump `&rest's argument.
  (()
   var p2 parameters
   (while p2
          setq new-parameters (cons (car p2) new-parameters)
          when = (car p2) (quote #&rest)
          setq p2 cdr p2
          setq p2 cdr p2))
  (()
   var np2 new-parameters
   setq new-parameters ()
   (while np2
          setq new-parameters (cons (car np2) new-parameters)
          setq np2 cdr np2))
  cons (quote #__defun) (cons name (cons new-parameters body)))
(declare defun (L L &rest 1 I)
         (
          (var name (infer-and-get-next-argument))
          (var parameters (infer-and-get-next-argument))
          (when (not = (type-of parameters) (type-of ()))
            setq parameters (list parameters))
          (var type ())
          (
           (var parameters parameters)
           (while parameters
                  (if (if (= (quote #&rest) (car parameters))
                          true
                          (= (type-of car parameters) (type-of 0)))
                      (setq type (cons car parameters type))
                      (setq type (cons (quote #I) type)))
                  (setq parameters (cdr parameters))))
          (
           (var type2 type)
           (setq type ())
           (while type2
                  (setq type (cons (car type2) type))
                  (setq type2 (cdr type2))))
          (declaration-scope
           (while parameters
                  var parameter car parameters
                  (when (when (= (type-of parameter) (type-of quote #a))
                          (not (= (quote #&rest) parameter)))
                    (declare-identifier parameter (quote #I)))
                  (setq parameters (cdr parameters)))
           (declare-identifier (quote #self) type)
           (infer-and-get-next-argument))
          (declare-identifier name type)))

(defmacro lambda (parameters &rest body) (L &rest 1 I)
  (when (not = (type-of parameters) (type-of ()))
    setq parameters (list parameters))
  var new-parameters ()
  ;; Dump `&rest's argument.
  (()
   var p2 parameters
   (while p2
          setq new-parameters (cons (car p2) new-parameters)
          when = (car p2) (quote #&rest)
          setq p2 cdr p2
          setq p2 cdr p2))
  (()
   var np2 new-parameters
   setq new-parameters ()
   (while np2
          setq new-parameters (cons (car np2) new-parameters)
          setq np2 cdr np2))
  cons (quote #__lambda) (cons new-parameters body))
(declare lambda (L &rest 1 I)
         (
          (var parameters (infer-and-get-next-argument))
          (when (not = (type-of parameters) (type-of ()))
            setq parameters (list parameters))
          (var type ())
          (
           (var parameters parameters)
           (while parameters
                  (if (if (= (quote #&rest) (car parameters))
                          true
                          (= (type-of car parameters) (type-of 0)))
                      (setq type (cons car parameters type))
                      (setq type (cons (quote #I) type)))
                  (setq parameters (cdr parameters))))
          (
           (var type2 type)
           (setq type ())
           (while type2
                  (setq type (cons (car type2) type))
                  (setq type2 (cdr type2))))
          (declaration-scope
           (while parameters
                  var parameter car parameters
                  (when (when (= (type-of parameter) (type-of quote #a))
                          (not (= (quote #&rest) parameter)))
                    (declare-identifier parameter (quote #I)))
                  (setq parameters (cdr parameters)))
           (declare-identifier (quote #self) type)
           (infer-and-get-next-argument))))

(defmacro scope (&rest body) (&rest 2 I) (cons () body))

(defmacro bothtime (&rest body) (&rest 1 I)
  (list (quote #__noscope)
        (cons (quote #__comptime)
              body)
        (cons (quote #__noscope)
              body)))

(defmacro bvar (name value) (L I)
  (funcall #bothtime (list (quote #__var) name value) ()))
(declare bvar (L I) (declare-identifier (infer-and-get-next-argument) (quote #L)))

(defmacro bdefun (name parameters &rest body) (L L &rest 1 I)
  (var defun (list (quote #defun) name parameters))
  (set-cdr (cdr (cdr defun)) body)
  (funcall #bothtime defun ()))
(declare bdefun (L L &rest 1 I)
         (
          (var name (infer-and-get-next-argument))
          (var parameters (infer-and-get-next-argument))
          (when (not = (type-of parameters) (type-of ()))
            setq parameters (list parameters))
          (var type ())
          (
           (var parameters parameters)
           (while parameters
                  (if (if (= (quote #&rest) (car parameters))
                          true
                          (= (type-of car parameters) (type-of 0)))
                      (setq type (cons car parameters type))
                      (setq type (cons (quote #I) type)))
                  (setq parameters (cdr parameters))))
          (
           (var type2 type)
           (setq type ())
           (while type2
                  (setq type (cons (car type2) type))
                  (setq type2 (cdr type2))))
          (declaration-scope
           (while parameters
                  var parameter car parameters
                  (when (when (= (type-of parameter) (type-of quote #a))
                          (not (= (quote #&rest) parameter)))
                    (declare-identifier parameter (quote #I)))
                  (setq parameters (cdr parameters)))
           (declare-identifier (quote #self) type)
           (infer-and-get-next-argument))
          (declare-identifier name type)))


bvar *epsilon* 1e-9


defmacro ' (code) (L) (list (quote #__quote) code)
bdefun cons (first second) cons first second
defmacro noscope (&rest body) (&rest 2 I) (cons ' __noscope body)
bdefun make-vector (size init) make-vector size init
bdefun get-vector-element (vector index) get-vector-element vector index
bdefun car (cons) car cons
bdefun cdr (cons) cdr cons
bdefun set-car (cons value) set-car cons value
bdefun set-cdr (cons value) set-cdr cons value
bdefun substring (string start-index end-index) substring string start-index end-index
bdefun length (sequence) length sequence
bdefun make-string (integer-sequence) make-string integer-sequence
(bdefun concatenate (first-string &rest 1 other-strings)
        (if other-strings
            (concatenate first-string (apply #self other-strings))
            first-string))
bdefun make-type () make-type
bdefun make-instance (type value-slot function-slot) (make-instance type value-slot function-slot)
bdefun composite-value (composite) (composite-value composite)
bdefun composite-function (composite) (composite-function composite)
bdefun set-composite-value (composite value) (set-composite-value composite value)
bdefun set-composite-function (composite function) (set-composite-function composite function)
bdefun null? (value) null? value
bdefun type-of (value) type-of value
bdefun not (value) not value
bdefun * (a &rest 1 b) (if b
                           * a (apply #self b)
                           a)
bdefun / (a &rest 1 b) (if b
                           / a (apply #self b)
                           a)
bdefun + (a &rest 1 b) (if b
                           + a (apply #self b)
                           a)
bdefun - (a &rest 1 b) (if b
                           - a (apply #self b)
                           a)
bdefun = (a b) = a b
bdefun < (a b) < a b
bdefun > (a b) > a b
bdefun symbol-string (symbol) symbol-string symbol

defmacro nil () () ()

bdefun 1+ (a) + a 1
bdefun 1- (a) - a 1

bdefun >= (x y) not < x y
bdefun <= (x y) not > x y
bdefun != (x y) not = x y
bdefun â‰  (x y) not = x y

(defmacro incq (variable &rest value) (L &rest 0 I)
  setq value car value
  (if value
      (list ' __setq variable (list ' __+ value variable))
      (list ' __setq variable (list ' __+ 1 variable))))

(defmacro decq (variable &rest value) (L &rest 0 I)
  setq value car value
  (if value
      (list ' __setq variable (list ' __+ value variable))
      (list ' __setq variable (list ' __- variable 1))))

(bdefun mod (a b)
        (- a (* (/ a b) b)))

(bdefun abs value
        (if < value 0
            - 0 value
            value))

(bdefun sqrt value
        var target value
        var running true
        var result 0
        var high target
        var low 0
        (while running
               var delta (- 1 (/ target (* value value)))
               (if < *epsilon* (abs delta)
                   (()
                    (if > 0 delta
                        setq low value
                        setq high value)
                    setq value (+ (/ (- high low) 2.0) low))
                   (()
                    setq result value
                    setq running false)))
        result)

bvar duckLisp-object-type-bool type-of false
bvar duckLisp-object-type-int type-of 0
bvar duckLisp-object-type-float type-of 0.0
bvar duckLisp-object-type-str type-of ""
bvar duckLisp-object-type-list type-of ()
bvar duckLisp-object-type-symbol type-of ' _
bvar duckLisp-object-type-closure type-of (lambda () ())
bvar duckLisp-object-type-vector type-of (vector)
bvar duckLisp-object-type-type type-of type-of ()

(bdefun bool? (value)
        (= (type-of value) duckLisp-object-type-bool))

(bdefun integer? (value)
        (= (type-of value) duckLisp-object-type-int))
(bdefun zero? (value) = 0 value)

(bdefun string? (value)
        (= (type-of value) duckLisp-object-type-str))

(bdefun list? (value)
        (= (type-of value) duckLisp-object-type-list))

(bdefun cons? (value)
        (= (type-of value) duckLisp-object-type-list))

(bdefun symbol? (value)
        (= (type-of value) duckLisp-object-type-symbol))

(bdefun closure? (value)
        (= (type-of value) duckLisp-object-type-closure))

(bdefun vector? (value)
        (= (type-of value) duckLisp-object-type-vector))

(bdefun type? (value)
        (= (type-of value) duckLisp-object-type-type))

(bdefun caar (x)
        (car (car x)))
(bdefun cadr (x)
        (car (cdr x)))
(bdefun cdar (x)
        (cdr (car x)))
(bdefun cddr (x)
        (cdr (cdr x)))
(bdefun caaar (x)
        (car (car (car x))))
(bdefun caadr (x)
        (car (car (cdr x))))
(bdefun cadar (x)
        (car (cdr (car x))))
(bdefun caddr (x)
        (car (cdr (cdr x))))
(bdefun cdaar (x)
        (cdr (car (car x))))
(bdefun cdadr (x)
        (cdr (car (cdr x))))
(bdefun cddar (x)
        (cdr (cdr (car x))))
(bdefun cdddr (x)
        (cdr (cdr (cdr x))))
(bdefun caaaar (x)
        (car (car (car (car x)))))
(bdefun caaadr (x)
        (car (car (car (cdr x)))))
(bdefun caadar (x)
        (car (car (cdr (car x)))))
(bdefun caaddr (x)
        (car (car (cdr (cdr x)))))
(bdefun cadaar (x)
        (car (cdr (car (car x)))))
(bdefun cadadr (x)
        (car (cdr (car (cdr x)))))
(bdefun caddar (x)
        (car (cdr (cdr (car x)))))
(bdefun cadddr (x)
        (car (cdr (cdr (cdr x)))))
(bdefun cdaaar (x)
        (cdr (car (car (car x)))))
(bdefun cdaadr (x)
        (cdr (car (car (cdr x)))))
(bdefun cdadar (x)
        (cdr (car (cdr (car x)))))
(bdefun cdaddr (x)
        (cdr (car (cdr (cdr x)))))
(bdefun cddaar (x)
        (cdr (cdr (car (car x)))))
(bdefun cddadr (x)
        (cdr (cdr (car (cdr x)))))
(bdefun cdddar (x)
        (cdr (cdr (cdr (car x)))))
(bdefun cddddr (x)
        (cdr (cdr (cdr (cdr x)))))

(bdefun first (list)
        (car list))
(bdefun second (list)
        (car (cdr list)))
(bdefun third (list)
        (car (cddr list)))
(bdefun fourth (list)
        (car (cdddr list)))
(bdefun fifth (list)
        (car (cddddr list)))
(bdefun sixth (list)
        (car (cdr (cddddr list))))
(bdefun seventh (list)
        (car (cddr (cddddr list))))
(bdefun eighth (list)
        (car (cdddr (cddddr list))))
(bdefun ninth (list)
        (car (cddddr (cddddr list))))
(bdefun tenth (list)
        (car (cdr (cddddr (cddddr list)))))

(bdefun rest (x)
        (cdr x))

(bdefun list* (&rest -1 args)
        (if (null? (rest args))
            (first args)
            (cons (first args) (apply #self (rest args)))))

(bdefun print (&rest 1 vs)
        (var vs2 vs)
        (while (not (null? vs2))
               (print (car vs2))
               (setq vs2 (cdr vs2)))
        vs)

(bdefun println (&rest 1 vs)
        (apply #print vs)
        (print "\n")
        vs)

(defmacro push (value variable) (I L)
  (list ' setq variable (list ' cons value variable)))

(defmacro pop (variable) (L)
  (list
   (list ' var ' pop-temp (list ' car variable))
   (list ' setq variable (list ' cdr variable))
   ' pop-temp))

(bdefun reverse (list)
        (var reversed-list ())
        (while (not (null? list))
               (setq reversed-list (cons (car list)
                                         reversed-list))
               pop list)
        reversed-list)
(bdefun nreverse (list) reverse list)

(defmacro and (&rest args) (&rest 2 I)
  (if args
	  (list ' if (car args)
              (apply #self (cdr args))
              false)
	  true))

(defmacro or (&rest args) (&rest 2 I)
  (if args
	  (list ' if (car args)
              true
              (apply #self (cdr args)))
	  false))

(bdefun truthy-constant? (value)
        (or (= value true)
            (and (string? value) value)
            (and (integer? value) value)))
(bdefun falsy-constant? (value)
        (or (= value false)
            (and (string? value) (not value))
            (and (integer? value) (not value))))

;; This is not the traditional lisp cond.
;;   (cond first-condition first-body
;;         second-condition second-body
;;         third-condition third-body
;;         â€¦ â€¦)
(defmacro cond (&rest body) (&rest -1 I)
  (if body
      (if (cdr body)
          (
           (var condition (first body))
           (if (truthy-constant? condition)
               (second body)
               (if (falsy-constant? condition)
                   (apply #self (cddr body))
                   (list ' if
                           condition
                           (second body)
                           (apply #self (cddr body))))))
          (first body))
      ()))

(defmacro switch (constant &rest body) (I &rest -1 I)
  (if body
      (if (cdr body)
          (list ' if
                  (list ' = constant (first body))
                  (second body)
                  (apply #self constant (cddr body)))
          (first body))
      ()))

(bdefun nth (n list)
        (var i 0)
        (while (< i n)
               (pop list)
               (incq i))
        (car list))

(bdefun elt (list n)
        (nth n list))

(bdefun last (list)
        (while (cdr list)
               (pop list))
        list)

(bdefun append (list1 list2)
        (var appended-list ())
        (while (not (null? list1))
               (setq appended-list (cons (car list1)
                                         appended-list))
               (pop list1))
        (while (not (null? list2))
               (setq appended-list (cons (car list2)
                                         appended-list))
               (pop list2))
        (nreverse appended-list))

(bdefun mapcar* (fun list)
        (unless (null? list)
          (cons (funcall fun (car list)) (self fun (cdr list)))))
(bdefun mapcar (fun list) mapcar* fun list)

;; Not the typical `dotimes'.
;;   (dotimes i 4
;;            (println i))
;; In the above example, the numbers 0-3 are printed.
;; `top' is only evaluated once. Returns `top'.
(defmacro dotimes (variable top &rest body) (L I &rest 1 I)
  (var top-var (gensym))
  (list
   (list ' var variable 0)
   (list ' var top-var top)
   (list ' while (list ' < variable top-var)
           (list* ' noscope body)
           (list ' incq variable))
   top-var))
(declare dotimes (L I &rest 1 I) (declare-identifier (infer-and-get-next-argument) (quote #I)))

;; Like `dolist`, but for generic sequences.
;;   (dosequence i (list 1 2 3)
;;               (println i))
;; In the above example, the numbers 1-3 are printed.
;; Returns the sequence. It is only evaluated once.
(defmacro dosequence (variable sequence &rest body) (L I &rest 1 I)
  (var sequence-var (gensym))
  (var return-var (gensym))
  (list
   (list (' var) sequence-var sequence)
   (list (' var) return-var sequence)
   (list (' var) variable ())
   (list (' while) (list (' not) (list (' null?) sequence-var))
         (list (' setq) variable (list (' car) sequence-var))
         (apply #noscope
                body)
         (list ' setq sequence-var (list ' cdr sequence-var)))
   return-var))
(declare dosequence (L I &rest 1 I) (declare-identifier (infer-and-get-next-argument) (quote #I)))

;; Not the typical `dolist'.
;;   (dolist i (list 1 2 3)
;;           (println i))
;; In the above example, the numbers 1-3 are printed.
;; Returns the list. It is only evaluated once.
(defmacro dolist (variable sequence &rest body) (L I &rest 1 I)
  (apply #dosequence variable sequence body))
(declare dolist (L I &rest 1 I) (declare-identifier (infer-and-get-next-argument) (quote #I)))



;; Semi-functional quasiquote. Vectors and composites are not fully implemented. Better error checking is needed.
;; Nested quasiquotes don't work properly.
;; ",", and ",@" need to be called as functions in order to match properly.
(defmacro quasiquote (form) (I)
  (switch (type-of form)
    duckLisp-object-type-list (when form
                                (
                                 (var sub-form (car form))
                                 (if (list? sub-form)
                                     (switch (car sub-form)
                                       ' , (list ' cons (cadr sub-form) (self (cdr form)))
                                       ' ,@ (list ' append
                                                    (cadr sub-form)
                                                    (self (cdr form)))
                                       (list ' cons (self (car form)) (self (cdr form))))
                                     (list ' cons (self (car form)) (self (cdr form))))))
    duckLisp-object-type-symbol (list ' quote form)
    duckLisp-object-type-closure (list ' error "`: Cannot quote closure object")
    duckLisp-object-type-vector (list ' quote form)
    duckLisp-object-type-type (list ' error "`: Cannot quote type object")
    form))
(declare quasiquote (I)
         (declaration-scope
          (declare-identifier (quote #,) (quote #I))
          (declare-identifier (quote #,@) (quote #I))
          infer-and-get-next-argument))
;; See above description of the backtick character.
(defmacro ` (form) (I) (funcall #quasiquote form))
(declare ` (I)
           (declaration-scope
            (declare-identifier (quote #,) (quote #(I)))
            (declare-identifier (quote #,@) (quote #(I)))
            infer-and-get-next-argument))


(defmacro until (condition &rest body) (I &rest 1 I)
  ` (while (not , condition) ,@ body))

comptime println "</comptime library.hna>"
println "</library.hna>"

;; If we are going to pause anywhere, this is the place
garbage-collect
