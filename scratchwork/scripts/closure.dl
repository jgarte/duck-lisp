
(defun println (x)
  (print x)
  (print "\n"))

(defun ptest (expected actual)
  (print expected)
  (println actual))

(comment Variables are numbered by scope.
		 All values should be printed in double.)
(println "Basic variable test")
(var x 1)
(ptest 1 x)

(println "Scope and shadowing test")
((println "{")
 (ptest 1 x)
 (var x 2)
 (ptest 2 x)
 (println "}"))
(ptest 1 x)

(println "Function scope and shadowing test")
(defun print-x (x)
  (println "{")
  (ptest 1 x)
  (comment This works?!? I'm pretty sure this should be an error.)
  (var x 2)
  (ptest 2 x)
  (println "}"))
(print-x x)

(println "Free variable test")
((var y 3)
 (defun dummy () x y)
 (defun print-free-x ()
   (println "{")
   (ptest 1 x)
   (ptest 3 y)
   (println "}"))
 (print-free-x))

(comment (println "Recursion test")
		 (defun recursion (x)
		   (println x)
		   (if (> x 0)
			   (
				(print 0)
				(recursion (- x 1)))
			   0))
		 (println "{")
		 (print 1)
		 (recursion 1)
		 (println "}")

		 (println "Type test")
		 (ptest 8 (type-of recursion)))

(println "Capture test")
(
 (var z 0)
 (
  (var y 7)
  (defun closure () y)
  (‚Üê z closure))
 (ptest 7 (funcall z)))

(println "Closure factory")
(println "{")
(
 (defun closure-factory (x)
   ((defun closure ()
	  x)))
 (var q (closure-factory 5))
 (var r (closure-factory 9))
 (comment Should read "closure # #")
 (ptest 5 (funcall q))
 (ptest 9 (funcall r)))
(println "}")

(println "Deeply nested closure")
(println "{")
(defun c1 ()
  (defun c2 ()
	(defun c3 ()
	  x)))
(println (funcall (funcall (c1))))
(println "}")

(comment (println "Factorial")
		 (println "{")
		 (defun Y (f) (funcall ((defun y1 (x) (funcall f (funcall x x))))
							   ((defun y1 (x) (funcall f (funcall x x))))))
		 (print-stack)
		 (defun factorial (f)
		   ((defun f1 (x)
			  (if (= x 1)
				  1
				  (* x (funcall f (- x 1)))))))
		 (defun c (x y)
		   (funcall ((defun n () (funcall x y)))))
		 (c println "Hello")
		 (println (funcall (Y factorial) 1))
		 (println "}"))
