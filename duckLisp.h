/*
MIT License

Copyright (c) 2021, 2022, 2023 Joseph Herguth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#ifndef DUCKLISP_H
#define DUCKLISP_H

#include "DuckLib/core.h"
#include "DuckLib/memory.h"
#include "DuckLib/array.h"
#include "DuckLib/trie.h"
#include "duckVM.h"

/*
node
	nodes_indices
	nodes_types
	nodes_length
	value
*/

/*
===
AST
===
*/

typedef enum {
	duckLisp_ast_type_none = 0,
	duckLisp_ast_type_expression,
	duckLisp_ast_type_literalExpression,
	duckLisp_ast_type_identifier,
	duckLisp_ast_type_callback,
	duckLisp_ast_type_string,
	duckLisp_ast_type_float,
	duckLisp_ast_type_int,
	duckLisp_ast_type_bool,
} duckLisp_ast_type_t;

typedef struct {
	dl_bool_t value;
} duckLisp_ast_bool_t;

typedef struct {
	dl_ptrdiff_t value;
} duckLisp_ast_integer_t;

typedef struct {
	double value;
} duckLisp_ast_float_t;

typedef struct {
	dl_uint8_t *value;
	dl_size_t value_length;
} duckLisp_ast_string_t;

typedef struct {
	dl_uint8_t *value;
	dl_size_t value_length;
} duckLisp_ast_identifier_t;

typedef struct {
	struct duckLisp_ast_compoundExpression_s *compoundExpressions;
	dl_size_t compoundExpressions_length;
} duckLisp_ast_expression_t;


typedef struct duckLisp_ast_compoundExpression_s {
	union {
		duckLisp_ast_expression_t expression;
		duckLisp_ast_identifier_t identifier;
		duckLisp_ast_string_t string;
		duckLisp_ast_bool_t boolean;
		duckLisp_ast_integer_t integer;
		duckLisp_ast_float_t floatingPoint;
	} value;
	duckLisp_ast_type_t type;
} duckLisp_ast_compoundExpression_t;

/*
=========
Variables
=========
*/

typedef enum {
	duckLisp_functionType_none = 0,
	duckLisp_functionType_c,
	duckLisp_functionType_ducklisp,
	/* Indicates that this procedure captures no upvalues. */
	duckLisp_functionType_generator,
	duckLisp_functionType_macro
} duckLisp_functionType_t;

typedef struct {
	/* All variable names in the current scope are stored here. */
	dl_trie_t locals_trie;   /* Points to stack objects. */
	dl_trie_t functionLocals_trie;   /* Points to stack objects. */

	/* This trie records all the function types in this scope. */
	dl_trie_t functions_trie;  /* dl_trie_t:duckLisp_functionType_t */
	dl_size_t functions_length;

	dl_trie_t macros_trie;  /* Index of macro in `macros`. */
	dl_size_t macros_length;

	dl_trie_t labels_trie;
	dl_bool_t function_scope;  /* Used to determine when to create a deep upvalue. */

	/* Upvalues */
	dl_ptrdiff_t *scope_uvs;
	dl_size_t scope_uvs_length;

	dl_ptrdiff_t *function_uvs;
	dl_size_t function_uvs_length;
} duckLisp_scope_t;

typedef struct {
	/* This is where we keep everything that needs to be scoped. */
	dl_array_t scope_stack;  /* dl_array_t:duckLisp_scope_t:{dl_trie_t} */
	dl_size_t locals_length;
	dl_size_t label_number;
	dl_array_t assembly;  /* dl_array_t:duckLisp_instructionObject_t This is always the true assembly array. */
} duckLisp_subCompileState_t;

/* This can safely be deleted after each compile. */
typedef struct duckLisp_compileState_s {
	duckLisp_subCompileState_t runtimeCompileState;
	duckLisp_subCompileState_t comptimeCompileState;
	duckLisp_subCompileState_t *currentCompileState;
} duckLisp_compileState_t;

#ifdef USE_DATALOGGING
typedef struct {
	/* Total number of instructions processed by the assembler since the compiler was initialized. */
	dl_size_t total_instructions_generated;
	/* Total number of bytes generated by the assembler since the compiler was initialized. */
	dl_size_t total_bytes_generated;
	/* Total number of instructions removed by the jump size optimizer peephole optimizer since the compiler was
	   initialized. */
	dl_size_t jumpsize_bytes_removed;
	/* Total number of instructions removed by the push-pop peephole optimizer since the compiler was initialized. */
	dl_size_t pushpop_instructions_removed;
} duckLisp_datalog_t;
#endif /* USE_DATALOGGING */

/* This remains until the compiler is destroyed. */
typedef struct {
	dl_memoryAllocation_t *memoryAllocation;

	dl_array_t errors;  /* dl_array_t:dl_uint8_t */

	dl_array_t generators_stack; /* dl_array_t:dl_error_t(*)(duckLisp_t*, const duckLisp_ast_expression_t) */
	dl_trie_t generators_trie;  /* Points to generator stack callbacks. */
	dl_size_t generators_length;

	dl_trie_t callbacks_trie;  /* Points to runtime C callbacks. */

#ifdef USE_PARENTHESIS_INFERENCE
	dl_array_t parenthesisInferrerTypes_array;  /* dl_array_t:duckLisp_parenthesisInferrer_declarationPrototype_t */
	dl_size_t maxInferenceVmObjects;
	dl_array_t inferrerLog;  /* dl_array_t:dl_uint8_t */
#endif /* USE_PARENTHESIS_INFERENCE */

	dl_size_t gensym_number;

	dl_trie_t comptimeGlobals_trie;  /* Index points to the string in `symbols_array` */
	dl_trie_t runtimeGlobals_trie;  /* Index points to the string in `symbols_array` */

	dl_trie_t symbols_trie;  /* Index points to the string in `symbols_array` */
	dl_array_t symbols_array;  /* duckLisp_ast_identifier_t */

	dl_trie_t parser_actions_trie;  /* Index points to the C callback in `parser_actions_array` */
	dl_array_t parser_actions_array;  /* dl_array_t:dl_error_t(*)(duckLisp_t*, duckLisp_ast_expression_t*) */
	dl_size_t parser_recursion_depth;
	dl_size_t parser_max_recursion_depth;

	dl_size_t generators_max_recursion_depth;
	dl_size_t generators_recursion_depth;

	/* A VM instance for macros. */
	duckVM_t vm;

#ifdef USE_DATALOGGING
	duckLisp_datalog_t datalog;
#endif /* USE_DATALOGGING */

	dl_bool_t disassemble;  /* Set to enable generation of disassembly. */
	dl_array_t disassemblies;  /* dl_array_t:dl_uint8_t* */

	dl_bool_t stripSymbolNames;  /* Set to make the string for each symbol empty. */

	void *userData;
} duckLisp_t;

/* An instruction class is the instruction name, but without any size information. This is used to indicate the
   instruction type in the high-level assembly array. */
typedef enum {
	duckLisp_instructionClass_nop = 0,
	duckLisp_instructionClass_pushString,
	duckLisp_instructionClass_pushBoolean,
	duckLisp_instructionClass_pushInteger,
	duckLisp_instructionClass_pushDoubleFloat,
	duckLisp_instructionClass_pushIndex,
	duckLisp_instructionClass_pushSymbol,
	duckLisp_instructionClass_pushStrippedSymbol,
	duckLisp_instructionClass_pushUpvalue,
	duckLisp_instructionClass_pushClosure,
	duckLisp_instructionClass_pushVaClosure,
	duckLisp_instructionClass_pushGlobal,
	duckLisp_instructionClass_setUpvalue,
	duckLisp_instructionClass_setStatic,
	duckLisp_instructionClass_releaseUpvalues,
	duckLisp_instructionClass_funcall,
	duckLisp_instructionClass_apply,
	duckLisp_instructionClass_call,
	duckLisp_instructionClass_ccall,
	duckLisp_instructionClass_acall,
	duckLisp_instructionClass_jump,
	duckLisp_instructionClass_brz,
	duckLisp_instructionClass_brnz,
	duckLisp_instructionClass_move,
	duckLisp_instructionClass_not,
	duckLisp_instructionClass_mul,
	duckLisp_instructionClass_div,
	duckLisp_instructionClass_add,
	duckLisp_instructionClass_sub,
	duckLisp_instructionClass_equal,
	duckLisp_instructionClass_less,
	duckLisp_instructionClass_greater,
	duckLisp_instructionClass_cons,
	duckLisp_instructionClass_vector,
	duckLisp_instructionClass_makeVector,
	duckLisp_instructionClass_getVecElt,
	duckLisp_instructionClass_setVecElt,
	duckLisp_instructionClass_car,
	duckLisp_instructionClass_cdr,
	duckLisp_instructionClass_setCar,
	duckLisp_instructionClass_setCdr,
	duckLisp_instructionClass_nullp,
	duckLisp_instructionClass_typeof,
	duckLisp_instructionClass_makeType,
	duckLisp_instructionClass_makeInstance,
	duckLisp_instructionClass_compositeValue,
	duckLisp_instructionClass_compositeFunction,
	duckLisp_instructionClass_setCompositeValue,
	duckLisp_instructionClass_setCompositeFunction,
	duckLisp_instructionClass_makeString,
	duckLisp_instructionClass_concatenate,
	duckLisp_instructionClass_substring,
	duckLisp_instructionClass_length,
	duckLisp_instructionClass_symbolString,
	duckLisp_instructionClass_symbolId,
	duckLisp_instructionClass_pop,
	duckLisp_instructionClass_return,
	duckLisp_instructionClass_halt,
	duckLisp_instructionClass_nil,
	duckLisp_instructionClass_pseudo_label,
	duckLisp_instructionClass_internalNop,
} duckLisp_instructionClass_t;

/* These are the opcodes. Unlike instruction classes they include size information. e.g. add16 takes two sixteen bit
   stack indices and uses the objects at those locations as the operands. */
/* Max number of instructions must be 256. */
/* Order should be 8→16→32 otherwise the new code may cause bugs in the peephole optimizer. */
typedef enum {
	duckLisp_instruction_nop = 0,

	duckLisp_instruction_pushString8,
	duckLisp_instruction_pushString16,
	duckLisp_instruction_pushString32,

	duckLisp_instruction_pushBooleanFalse,
	duckLisp_instruction_pushBooleanTrue,

	duckLisp_instruction_pushInteger8,
	duckLisp_instruction_pushInteger16,
	duckLisp_instruction_pushInteger32,

	duckLisp_instruction_pushDoubleFloat,

	duckLisp_instruction_pushIndex8,
	duckLisp_instruction_pushIndex16,
	duckLisp_instruction_pushIndex32,

	duckLisp_instruction_pushSymbol8,
	duckLisp_instruction_pushSymbol16,
	duckLisp_instruction_pushSymbol32,

	duckLisp_instruction_pushStrippedSymbol8,
	duckLisp_instruction_pushStrippedSymbol16,
	duckLisp_instruction_pushStrippedSymbol32,

	duckLisp_instruction_pushUpvalue8,
	duckLisp_instruction_pushUpvalue16,
	duckLisp_instruction_pushUpvalue32,

	duckLisp_instruction_pushClosure8,
	duckLisp_instruction_pushClosure16,
	duckLisp_instruction_pushClosure32,

	duckLisp_instruction_pushVaClosure8,
	duckLisp_instruction_pushVaClosure16,
	duckLisp_instruction_pushVaClosure32,

	duckLisp_instruction_pushGlobal8,

	duckLisp_instruction_setUpvalue8,
	duckLisp_instruction_setUpvalue16,
	duckLisp_instruction_setUpvalue32,

	duckLisp_instruction_setStatic8,

	duckLisp_instruction_releaseUpvalues8,
	duckLisp_instruction_releaseUpvalues16,
	duckLisp_instruction_releaseUpvalues32,

	duckLisp_instruction_funcall8,
	duckLisp_instruction_funcall16,
	duckLisp_instruction_funcall32,

	duckLisp_instruction_apply8,
	duckLisp_instruction_apply16,
	duckLisp_instruction_apply32,

	duckLisp_instruction_call8,
	duckLisp_instruction_call16,
	duckLisp_instruction_call32,

	duckLisp_instruction_ccall8,
	duckLisp_instruction_ccall16,
	duckLisp_instruction_ccall32,

	duckLisp_instruction_acall8,
	duckLisp_instruction_acall16,
	duckLisp_instruction_acall32,

	duckLisp_instruction_jump8,
	duckLisp_instruction_jump16,
	duckLisp_instruction_jump32,

	duckLisp_instruction_brz8,
	duckLisp_instruction_brz16,
	duckLisp_instruction_brz32,

	duckLisp_instruction_brnz8,
	duckLisp_instruction_brnz16,
	duckLisp_instruction_brnz32,

	duckLisp_instruction_move8,
	duckLisp_instruction_move16,
	duckLisp_instruction_move32,

	duckLisp_instruction_not8,
	duckLisp_instruction_not16,
	duckLisp_instruction_not32,

	duckLisp_instruction_mul8,
	duckLisp_instruction_mul16,
	duckLisp_instruction_mul32,

	duckLisp_instruction_div8,
	duckLisp_instruction_div16,
	duckLisp_instruction_div32,

	duckLisp_instruction_add8,
	duckLisp_instruction_add16,
	duckLisp_instruction_add32,

	duckLisp_instruction_sub8,
	duckLisp_instruction_sub16,
	duckLisp_instruction_sub32,

	duckLisp_instruction_equal8,
	duckLisp_instruction_equal16,
	duckLisp_instruction_equal32,

	duckLisp_instruction_greater8,
	duckLisp_instruction_greater16,
	duckLisp_instruction_greater32,

	duckLisp_instruction_less8,
	duckLisp_instruction_less16,
	duckLisp_instruction_less32,

	duckLisp_instruction_cons8,
	duckLisp_instruction_cons16,
	duckLisp_instruction_cons32,

	duckLisp_instruction_vector8,
	duckLisp_instruction_vector16,
	duckLisp_instruction_vector32,

	duckLisp_instruction_makeVector8,
	duckLisp_instruction_makeVector16,
	duckLisp_instruction_makeVector32,

	duckLisp_instruction_getVecElt8,
	duckLisp_instruction_getVecElt16,
	duckLisp_instruction_getVecElt32,

	duckLisp_instruction_setVecElt8,
	duckLisp_instruction_setVecElt16,
	duckLisp_instruction_setVecElt32,

	duckLisp_instruction_car8,
	duckLisp_instruction_car16,
	duckLisp_instruction_car32,

	duckLisp_instruction_cdr8,
	duckLisp_instruction_cdr16,
	duckLisp_instruction_cdr32,

	duckLisp_instruction_setCar8,
	duckLisp_instruction_setCar16,
	duckLisp_instruction_setCar32,

	duckLisp_instruction_setCdr8,
	duckLisp_instruction_setCdr16,
	duckLisp_instruction_setCdr32,

	duckLisp_instruction_nullp8,
	duckLisp_instruction_nullp16,
	duckLisp_instruction_nullp32,

	duckLisp_instruction_typeof8,
	duckLisp_instruction_typeof16,
	duckLisp_instruction_typeof32,

	duckLisp_instruction_makeType,

	duckLisp_instruction_makeInstance8,
	duckLisp_instruction_makeInstance16,
	duckLisp_instruction_makeInstance32,

	duckLisp_instruction_compositeValue8,
	duckLisp_instruction_compositeValue16,
	duckLisp_instruction_compositeValue32,

	duckLisp_instruction_compositeFunction8,
	duckLisp_instruction_compositeFunction16,
	duckLisp_instruction_compositeFunction32,

	duckLisp_instruction_setCompositeValue8,
	duckLisp_instruction_setCompositeValue16,
	duckLisp_instruction_setCompositeValue32,

	duckLisp_instruction_setCompositeFunction8,
	duckLisp_instruction_setCompositeFunction16,
	duckLisp_instruction_setCompositeFunction32,

	duckLisp_instruction_makeString8,
	duckLisp_instruction_makeString16,
	duckLisp_instruction_makeString32,

	duckLisp_instruction_concatenate8,
	duckLisp_instruction_concatenate16,
	duckLisp_instruction_concatenate32,

	duckLisp_instruction_substring8,
	duckLisp_instruction_substring16,
	duckLisp_instruction_substring32,

	duckLisp_instruction_length8,
	duckLisp_instruction_length16,
	duckLisp_instruction_length32,

	duckLisp_instruction_symbolString8,
	duckLisp_instruction_symbolString16,
	duckLisp_instruction_symbolString32,

	duckLisp_instruction_symbolId8,
	duckLisp_instruction_symbolId16,
	duckLisp_instruction_symbolId32,

	duckLisp_instruction_pop8,
	duckLisp_instruction_pop16,
	duckLisp_instruction_pop32,

	duckLisp_instruction_return0,
	duckLisp_instruction_return8,
	duckLisp_instruction_return16,
	duckLisp_instruction_return32,

	duckLisp_instruction_halt,

	duckLisp_instruction_nil,
} duckLisp_instruction_t;

typedef enum {
	duckLisp_instructionArgClass_type_none,
	duckLisp_instructionArgClass_type_integer,
	duckLisp_instructionArgClass_type_doubleFloat,
	/* "index" could probably be removed. It should be known what the argument type is from the context. In fact, do I
	   even need this enum if that is the case? */
	duckLisp_instructionArgClass_type_index,
	duckLisp_instructionArgClass_type_string,
} duckLisp_instructionArgClass_type_t;

/* This is the struct used for each argument of each element of high-level assembly. */
typedef struct {
	union {
		dl_ptrdiff_t integer;
		dl_ptrdiff_t index;
		double doubleFloat;
		struct {
			char *value;
			dl_size_t value_length;
		} string;
	} value;
	duckLisp_instructionArgClass_type_t type;
} duckLisp_instructionArgClass_t;

/* This is the struct used for each element of high-level assembly. */
typedef struct duckLisp_instructionObject_s {
	duckLisp_instructionClass_t instructionClass;
	dl_array_t args;  /* dl_array_t:duckLisp_instructionArgClass_t */
} duckLisp_instructionObject_t;



/* Initialize an instance of the compiler. */
dl_error_t duckLisp_init(duckLisp_t *duckLisp,
                         dl_memoryAllocation_t *memoryAllocation,
                         dl_size_t maxComptimeVmObjects
#ifdef USE_PARENTHESIS_INFERENCE
                         ,
                         dl_size_t maxInferenceVmObjects
#endif /* USE_PARENTHESIS_INFERENCE */
                         );
/* Free an instance of the compiler. */
void DECLSPEC duckLisp_quit(duckLisp_t *duckLisp);

/* Internal function that is needed for compiling AST. Should probably hide. */
void DECLSPEC duckLisp_compileState_init(duckLisp_t *duckLisp, duckLisp_compileState_t *compileState);
/* Internal function that is needed for compiling AST. Should probably hide. */
dl_error_t DECLSPEC duckLisp_compileState_quit(duckLisp_t *duckLisp, duckLisp_compileState_t *compileState);

/* Report a compile-time error when the position of the error in the source code is unknown. */
dl_error_t DECLSPEC duckLisp_error_pushRuntime(duckLisp_t *duckLisp,
                                               const dl_uint8_t *message,
                                               const dl_size_t message_length);
/* Check if the number of arguments in the form matches what is expected. Throw an error otherwise. */
dl_error_t DECLSPEC duckLisp_checkArgsAndReportError(duckLisp_t *duckLisp, duckLisp_ast_expression_t astExpression,
                                                     const dl_size_t numArgs,
                                                     const dl_bool_t variadic);
/* Check the type of an error to make sure it is what was expected. Throw an error otherwise. */
dl_error_t DECLSPEC duckLisp_checkTypeAndReportError(duckLisp_t *duckLisp,
                                                     duckLisp_ast_identifier_t functionName,
                                                     duckLisp_ast_compoundExpression_t astCompoundExpression,
                                                     const duckLisp_ast_type_t type);

/* Get the top of the scope stack for the current sub-compile-state. */
dl_error_t duckLisp_scope_getTop(duckLisp_t *duckLisp,
                                 duckLisp_subCompileState_t *subCompileState,
                                 duckLisp_scope_t *scope);
dl_error_t duckLisp_scope_getMacroFromName(duckLisp_subCompileState_t *subCompileState,
                                           dl_ptrdiff_t *index,
                                           const dl_uint8_t *name,
                                           const dl_size_t name_length);
dl_error_t duckLisp_scope_getLocalIndexFromName(duckLisp_subCompileState_t *subCompileState,
                                                dl_ptrdiff_t *index,
                                                const dl_uint8_t *name,
                                                const dl_size_t name_length,
                                                const dl_bool_t functionsOnly);
dl_error_t duckLisp_scope_getFreeLocalIndexFromName(duckLisp_t *duckLisp,
                                                    duckLisp_subCompileState_t *subCompileState,
                                                    dl_bool_t *found,
                                                    dl_ptrdiff_t *index,
                                                    dl_ptrdiff_t *scope_index,
                                                    const dl_uint8_t *name,
                                                    const dl_size_t name_length,
                                                    const dl_bool_t functionsOnly);
dl_error_t duckLisp_scope_getFunctionFromName(duckLisp_t *duckLisp,
                                              duckLisp_subCompileState_t *subCompileState,
                                              duckLisp_functionType_t *functionType,
                                              dl_ptrdiff_t *index,
                                              const dl_uint8_t *name,
                                              const dl_size_t name_length);
dl_error_t duckLisp_scope_getGlobalFromName(duckLisp_t *duckLisp,
                                            dl_ptrdiff_t *symbolId,
                                            const dl_uint8_t *name,
                                            const dl_size_t name_length,
                                            const dl_bool_t isComptime);
dl_error_t duckLisp_scope_getLabelFromName(duckLisp_subCompileState_t *subCompileState,
                                           dl_ptrdiff_t *index,
                                           const dl_uint8_t *name,
                                           dl_size_t name_length);

/* Increment the locals length in the current sub-compile-state. */
void duckLisp_localsLength_increment(duckLisp_compileState_t *compileState);
/* Decrement the locals length in the current sub-compile-state. */
void duckLisp_localsLength_decrement(duckLisp_compileState_t *compileState);
/* Get the locals length for the current sub-compile-state. */
dl_size_t duckLisp_localsLength_get(duckLisp_compileState_t *compileState);

/* Create a unique identifier name that is unlikely (but not impossible! D:) to be referenced by the author of a
   duck-lisp script. */
dl_error_t duckLisp_gensym(duckLisp_t *duckLisp, duckLisp_ast_identifier_t *identifier);
dl_error_t duckLisp_register_label(duckLisp_t *duckLisp,
                                   duckLisp_subCompileState_t *subCompileState,
                                   dl_uint8_t *name,
                                   const dl_size_t name_length);

/* Convert an AST into a data structure made out of duckVM objects. */
dl_error_t duckLisp_astToObject(duckLisp_t *duckLisp,
                                duckVM_t *duckVM,
                                duckVM_object_t *object,
                                duckLisp_ast_compoundExpression_t ast);

dl_error_t duckLisp_consToExprAST(duckLisp_t *duckLisp,
                                  duckLisp_ast_compoundExpression_t *ast,
                                  duckVM_object_t *cons);
dl_error_t duckLisp_consToConsAST(duckLisp_t *duckLisp,
                                  duckLisp_ast_compoundExpression_t *ast,
                                  duckVM_object_t *cons);
dl_error_t duckLisp_objectToAST(duckLisp_t *duckLisp,
                                duckLisp_ast_compoundExpression_t *ast,
                                duckVM_object_t *object,
                                dl_bool_t useExprs);



dl_error_t duckLisp_compile_compoundExpression(duckLisp_t *duckLisp,
                                               duckLisp_compileState_t *compileState,
                                               dl_array_t *assembly,
                                               dl_uint8_t *functionName,
											   const dl_size_t functionName_length,
											   duckLisp_ast_compoundExpression_t *compoundExpression,
											   dl_ptrdiff_t *index,
                                               duckLisp_ast_type_t *type,
											   dl_bool_t pushReference);
dl_error_t duckLisp_compile_expression(duckLisp_t *duckLisp,
                                       duckLisp_compileState_t *compileState,
                                       dl_array_t *assembly,
                                       dl_uint8_t *functionName,
                                       const dl_size_t functionName_length,
                                       duckLisp_ast_expression_t *expression,
                                       dl_ptrdiff_t *index);

dl_error_t duckLisp_instructionObject_quit(duckLisp_t *duckLisp, duckLisp_instructionObject_t *instruction);
/* Assemble the high-level assembly array to bytecode. I think `compileState` is required for the number of labels. I
   should change that. */
dl_error_t duckLisp_assemble(duckLisp_t *duckLisp,
                             duckLisp_compileState_t *compileState,
                             dl_array_t *bytecode,
                             dl_array_t *assembly,
                             dl_bool_t stripSymbolNames);
/* Initialize the high-level assembly array. */
void duckLisp_assembly_init(duckLisp_t *duckLisp, dl_array_t *assembly);
/* Free the high-level assembly array. */
dl_error_t duckLisp_assembly_quit(duckLisp_t *duckLisp, dl_array_t *assembly);
/* Compile an AST. I should probably make `compileState` not required. */
dl_error_t duckLisp_compileAST(duckLisp_t *duckLisp,
                               duckLisp_compileState_t *compileState,
                               dl_array_t *bytecode,  /* dl_array_t:dl_uint8_t */
                               duckLisp_ast_compoundExpression_t astCompoundexpression,
                               dl_bool_t stripSymbolNames);

/* Intern an identifier name as a symbol. */
dl_error_t duckLisp_symbol_create(duckLisp_t *duckLisp, const dl_uint8_t *name, const dl_size_t name_length);
/* Get the ID of a symbol from its name. */
dl_ptrdiff_t duckLisp_symbol_nameToValue(const duckLisp_t *duckLisp, const dl_uint8_t *name, const dl_size_t name_length);
/* Compile duck-lisp source code. */
dl_error_t duckLisp_loadString(duckLisp_t *duckLisp,
#ifdef USE_PARENTHESIS_INFERENCE
                               const dl_bool_t parenthesisInferenceEnabled,
#endif /* USE_PARENTHESIS_INFERENCE */
                               dl_uint8_t **bytecode,
                               dl_size_t *bytecode_length,
                               const dl_uint8_t *source,
                               const dl_size_t source_length,
                               const dl_uint8_t *fileName,
                               const dl_size_t fileName_length);

/* Push a scope on top of the current scope stack. */
dl_error_t DECLSPEC duckLisp_pushScope(duckLisp_t *duckLisp,
                                       duckLisp_compileState_t *compileState,
                                       duckLisp_scope_t *scope,
                                       dl_bool_t is_function);
/* Pop a scope off of the top of the current scope stack. */
dl_error_t DECLSPEC duckLisp_popScope(duckLisp_t *duckLisp,
                                      duckLisp_compileState_t *compileState,
                                      duckLisp_scope_t *scope);
dl_error_t duckLisp_addGlobal(duckLisp_t *duckLisp,
                              const dl_uint8_t *name,
                              const dl_size_t name_length,
                              dl_ptrdiff_t *index,
                              const dl_bool_t comptime);
dl_error_t DECLSPEC duckLisp_scope_addObject(duckLisp_t *duckLisp,
                                             duckLisp_compileState_t *compileState,
                                             const dl_uint8_t *name,
                                             const dl_size_t name_length);
dl_error_t duckLisp_addInterpretedFunction(duckLisp_t *duckLisp,
                                           duckLisp_compileState_t *compileState,
                                           const duckLisp_ast_identifier_t name);
dl_error_t duckLisp_addInterpretedGenerator(duckLisp_t *duckLisp,
                                            duckLisp_compileState_t *compileState,
                                            const duckLisp_ast_identifier_t name);
dl_error_t duckLisp_addParserAction(duckLisp_t *duckLisp,
                                    dl_error_t (*callback)(duckLisp_t*, duckLisp_ast_compoundExpression_t*),
                                    const dl_uint8_t *name,
                                    const dl_size_t name_length);
dl_error_t duckLisp_addGenerator(duckLisp_t *duckLisp,
                                 dl_error_t (*callback)(duckLisp_t*,
                                                        duckLisp_compileState_t *,
                                                        dl_array_t*,
                                                        duckLisp_ast_expression_t*),
                                 dl_uint8_t *name,
                                 const dl_size_t name_length
#ifdef USE_PARENTHESIS_INFERENCE
                                 ,
                                 dl_uint8_t *typeString,
                                 const dl_size_t typeString_length,
                                 dl_uint8_t *declarationScript,
                                 const dl_size_t declarationScript_length
#endif /* USE_PARENTHESIS_INFERENCE */
                                 );
dl_error_t duckLisp_linkCFunction(duckLisp_t *duckLisp,
                                  dl_error_t (*callback)(duckVM_t *),
                                  dl_uint8_t *name,
                                  const dl_size_t name_length
#ifdef USE_PARENTHESIS_INFERENCE
                                  ,
                                  dl_uint8_t *typeString,
                                  const dl_size_t typeString_length
#endif /* USE_PARENTHESIS_INFERENCE */
                                  );

/* Disassemble bytecode into a string. */
dl_error_t duckLisp_disassemble(dl_array_t *string,
                                dl_memoryAllocation_t *memoryAllocation,
                                const dl_uint8_t *bytecode,
                                const dl_size_t length);


/* Pretty printing functions for debugging. */

dl_error_t duckLisp_ast_type_prettyPrint(dl_array_t *string_array, duckLisp_ast_type_t type);
dl_error_t duckLisp_ast_bool_prettyPrint(dl_array_t *string_array, duckLisp_ast_bool_t boolean);
dl_error_t duckLisp_ast_integer_prettyPrint(dl_array_t *string_array, duckLisp_ast_integer_t integer);
dl_error_t duckLisp_ast_float_prettyPrint(dl_array_t *string_array, duckLisp_ast_float_t floatingPoint);
dl_error_t duckLisp_ast_string_prettyPrint(dl_array_t *string_array, duckLisp_ast_string_t string);
dl_error_t duckLisp_ast_identifier_prettyPrint(dl_array_t *string_array, duckLisp_ast_identifier_t identifier);
dl_error_t duckLisp_ast_expression_prettyPrint(dl_array_t *string_array, duckLisp_ast_expression_t expression);
dl_error_t duckLisp_ast_compoundExpression_prettyPrint(dl_array_t *string_array,
                                                       duckLisp_ast_compoundExpression_t compoundExpression);
dl_error_t duckLisp_functionType_prettyPrint(dl_array_t *string_array, duckLisp_functionType_t functionType);
dl_error_t duckLisp_scope_prettyPrint(dl_array_t *string_array, duckLisp_scope_t scope);
dl_error_t duckLisp_subCompileState_prettyPrint(dl_array_t *string_array, duckLisp_subCompileState_t subCompileState);
dl_error_t duckLisp_compileState_prettyPrint(dl_array_t *string_array, duckLisp_compileState_t compileState);
#ifdef USE_DATALOGGING
dl_error_t duckLisp_datalog_prettyPrint(dl_array_t *string_array, duckLisp_datalog_t datalog);
#endif /* USE_DATALOGGING */
dl_error_t duckLisp_prettyPrint(dl_array_t *string_array, duckLisp_t duckLisp);
dl_error_t duckLisp_instructionArgClass_type_prettyPrint(dl_array_t *string_array,
                                                         duckLisp_instructionArgClass_type_t type);
dl_error_t duckLisp_instructionArgClass_prettyPrint(dl_array_t *string_array,
                                                    duckLisp_instructionArgClass_t instructionArgClass);
dl_error_t duckLisp_instructionClass_prettyPrint(dl_array_t *string_array,
                                                 duckLisp_instructionClass_t instructionClass);
dl_error_t duckLisp_instructionObject_prettyPrint(dl_array_t *string_array,
                                                  duckLisp_instructionObject_t instructionObject);

#endif /* DUCKLISP_H */
